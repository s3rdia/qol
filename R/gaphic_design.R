#' Generate Graphics While Fully Concentrating On Design
#'
#' @description
#' [design_graphic()] produces fully styled diagrams. The many parameters are all
#' focused around making visual changes simple and fast. All diagrams can be exported
#' into multiple formats.
#'
#' The diagram parameter takes in a function for the main diagram area, making the
#' function modular and extendable.
#'
#' @param data_frame A data frame in which are the variables to tabulate.
#' @param axes_variables A vector that provides single variables or variable combinations
#' that should appear on the variable axes. To nest variables use the form:
#' "var1 + var2 + var3 + ...".
#' @param segments A vector that provides variables that should appear as the graphics
#' segments.
#' @param values A vector containing all variables that should be summarised.
#' @param statistics Available functions:
#' - "sum"       -> Weighted and unweighted sum
#' - "sum_wgt"   -> Sum of all weights
#' - "freq"      -> Unweighted frequency
#' - "freq_g0"   -> Unweighted frequency of all values greater than zero
#' - "pct_group" -> Weighted and unweighted percentages within the respective group
#' - "pct_value" -> Weighted and unweighted percentages between value variables
#' - "pct_total" -> Weighted and unweighted percentages compared to the grand total
#' - "mean"      -> Weighted and unweighted mean
#' - "median"    -> Weighted and unweighted median
#' - "mode"      -> Weighted and unweighted mode
#' - "min"       -> Minimum
#' - "max"       -> Maximum
#' - "sd"        -> Weighted and unweighted standard deviation
#' - "variance"  -> Weighted and unweighted standard variance
#' - "first"     -> First value
#' - "last"      -> Last value
#' - "pn"        -> Weighted and unweighted percentiles (any p1, p2, p3, ... possible)
#' - "missing"   -> Missings generated by the value variables
#' @param pct_group If pct_group is specified in the statistics, this option is used to
#' determine which variable of the row and column variables should add up to 100 %.
#' Multiple variables can be specified in a vector to generate multiple group percentages.
#' @param pct_value If pct_value is specified in the statistics, you can pass a list here
#' which contains the information for a new variable name and between which of the value
#' variables percentages should be computed.
#' @param formats A list in which is specified which formats should be applied to which variables.
#' @param by Compute tables stratified by the expressions of the provided variables.
#' @param weight Put in a weight variable to compute weighted results.
#' @param titles Specify one or more table titles.
#' @param footnotes Specify one or more table footnotes.
#' @param var_labels A list in which is specified which label should be printed for
#' which variable instead of the variable name.
#' @param stat_labels A list in which is specified which label should be printed for
#' which statistic instead of the statistic name.
#' @param diagram Function that provides the generation of the main diagram area.
#' @param color_theme The color theme to use. Can either be the name of a built-in or
#' custom theme or a vector of hex codes. Existing color themes can be viewed with
#' [display_themes()].
#' @param color_usage A list of numerical vectors that specify which specific colors
#' from the color scheme are used for which number of segments.
#' @param visuals Visual parameters set with [graphic_visuals()].
#' @param axes Axes parameters set with [graphic_axes()].
#' @param dimensions Dimension parameters set with [graphic_dimensions()].
#' @param number_formats Number formats set with [number_format_style()].
#' @param add_texts Use the [add_textbox()] function to freely place one or multiple textboxes.
#' @param output Output parameters set with [graphic_output()].
#' @param na.rm FALSE by default. If TRUE removes all NA values from the variables.
#' @param print_miss FALSE by default. If TRUE outputs all possible categories of the
#' grouping variables based on the provided formats, even if there are no observations
#' for a combination.
#' @param print TRUE by default. If TRUE prints the output, if FALSE doesn't print anything. Can be used
#' if one only wants to catch the output data frame and workbook with meta information.
#' @param monitor FALSE by default. If TRUE, outputs two charts to visualize the functions time consumption.
#'
#' @details
#' [design_graphic()] is based on the 'SAS' procedure Proc Tabulate, which provides
#' efficient and readable ways to perform complex Generating graphics.
#'
#' @return
#' Returns a list with the data table containing the results for the graphic and the
#' final grid::gTree graphics object.
#'
#' @seealso
#' Graphic options: [graphic_visuals()], [modify_graphic_visuals()], [graphic_axes()],
#' [modify_graphic_axes()], [graphic_dimensions()], [modify_graphic_dimensions()],
#' [graphic_output()], [modify_graphic_output()]
#'
#' Global graphic options: [graphic_visuals()], [add_color_theme()], [get_theme_colors()],
#' [get_theme_base_colors()], [get_theme_font_inside_colors()], [get_theme_font_outside_colors()],
#' [reset_color_themes()]
#'
#' Main diagrams: [vbars()]
#'
#' View colors and themes: [display_colors()], [display_themes()]
#'
#' Mid level functions:
#' - Textboxes: [add_textbox()], [add_title()], [add_footnote()], [add_graphic_origin()],
#' [wrap_single_text()], [wrap_text_vector()], [register_windows_font()]
#' - Viewport: [setup_main_canvas()], [setup_nested_viewport()], [setup_diagram_viewport()],
#' [setup_nested_diagram_viewport()], [back_to_the_root()], [is_viewport_pushed()]
#' - Dimensions: [get_available_width()], [get_available_height()]
#' - Diagram: [get_diagram_dimensions()], [vbar_grob()]
#' - Axes: [get_value_axes_width()], [get_variable_axes_dimension()], [get_values_dimension()],
#' [get_group_tick_positions_x()],
#' [get_y_axes_values()], [setup_y_axes()], [setup_x_axes()], [setup_xy_axes()]
#' - Labels: [direct_vertical_labels()]
#' - Output: [output_graphic()]
#' - Other: [format_values()]
#'
#' Creating formats: [discrete_format()] and [interval_format()].
#'
#' Functions that can handle formats and styles: [frequencies()], [crosstabs()], [any_table()].
#'
#' Additional functions that can handle styles: [export_with_style()]
#'
#' Additional functions that can handle formats: [summarise_plus()], [recode()],
#' [recode_multi()], [transpose_plus()], [sort_plus()]
#'
#' @examples
#' # Example data frame
#' my_data <- dummy_data(1000)
#'
#' # Formats
#' age. <- discrete_format(
#'     "Total"          = 0:100,
#'     "under 18"       = 0:17,
#'     "18 to under 25" = 18:24,
#'     "25 to under 55" = 25:54,
#'     "55 to under 65" = 55:64,
#'     "65 and older"   = 65:100)
#'
#' sex. <- discrete_format(
#'     "Total"  = 1:2,
#'     "Male"   = 1,
#'     "Female" = 2)
#'
#' # Design grouped vertical bar chart
#' qol_graphic <- my_data |>
#'      design_graphic(axes_variables = "age",
#'                     segments       = "sex",
#'                     values         = weight,
#'                     diagram        = vbars,
#'                     formats        = list(sex = sex., age = age.),
#'                     titles         = "The qol-package brings powerful concepts
#'                                       from 'SAS' to 'R' to make life easier and
#'                                       produce bigger and more complex outputs in
#'                                       less time with less code.",
#'                     footnotes      = "The qol-package brings powerful concepts
#'                                       from 'SAS' to 'R' to make life easier and
#'                                       produce bigger and more complex outputs in
#'                                       less time with less code.")
#'
#' @export
design_graphic <- function(data_frame,
                           axes_variables,
                           segments,
                           values,
                           statistics     = "pct_group",
                           pct_value      = list(),
                           formats        = list(),
                           by             = c(),
                           weight         = NULL,
                           titles         = .qol_options[["titles"]],
                           footnotes      = .qol_options[["footnotes"]],
                           var_labels     = .qol_options[["var_labels"]],
                           stat_labels    = .qol_options[["stat_labels"]],
                           diagram        = vbars,
                           color_theme    = "ocean",
                           color_usage    = .qol_options[["graphic_color_usage"]],
                           visuals        = .qol_options[["graphic_visuals"]],
                           axes           = .qol_options[["graphic_axes"]],
                           dimensions     = .qol_options[["graphic_dimensions"]],
                           number_formats = .qol_options[["graphic_number_formats"]],
                           add_texts      = .qol_options[["graphic_texts"]],
                           output         = .qol_options[["graphic_output"]],
                           na.rm          = .qol_options[["na.rm"]],
                           print_miss     = .qol_options[["print_miss"]],
                           print          = .qol_options[["print"]],
                           monitor        = .qol_options[["monitor"]]){

    # Measure the time
    start_time <- Sys.time()

    #-------------------------------------------------------------------------#
    monitor_df <- NULL |> monitor_start("Error handling", "Preparation")
    #-------------------------------------------------------------------------#

    ###########################################################################
    # Early evaluations
    ###########################################################################

    # First convert data frame to data table
    if (!data.table::is.data.table(data_frame)){
        data_frame <- data.table::as.data.table(data_frame)
    }

    # Evaluate formats early
    if (!is_list_of_dfs(formats)){
        formats_list <- as.list(substitute(formats))[-1]
        formats      <- evaluate_formats(formats_list)
    }

    ###########################################################################
    # Error handling
    ###########################################################################

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Axes variables
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    # Enable the use of macro variables
    axes_variables <- apply_macro(axes_variables)

    # Get row variables from provided combinations
    axes_vars <- unlist_variables(axes_variables)

    if (is.null(axes_vars)){
        message(" X ERROR: <Axes variables> must be provided in quotation marks. Generating graphic will be aborted.")
        return(invisible(NULL))
    }

    axes_vars <- data_frame |> part_of_df(axes_vars, check_only = TRUE)

    if (is.list(axes_vars)){
        message(" X ERROR: The provided <axes variables> '", paste(axes_vars[[1]], collapse = ", "), "' is not part of\n",
                "          the data frame. Generating graphic will be aborted.")
        return(invisible(NULL))
    }

    if (length(axes_variables) <= 1){
        if (length(axes_variables) == 0 || axes_variables == ""){
            message(" X ERROR: No valid <axes variables> provided. Generating graphic will be aborted.")
            return(invisible(NULL))
        }
    }

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Segment variables
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    # Enable the use of macro variables
    segments <- apply_macro(segments)

    # Get row variables from provided combinations
    segment_vars <- unlist_variables(segments)

    if (is.null(segment_vars)){
        message(" X ERROR: <Segments> variables must be provided in quotation marks. Generating graphic will be aborted.")
        return(invisible(NULL))
    }

    segment_vars <- data_frame |> part_of_df(segment_vars, check_only = TRUE)

    if (is.list(segment_vars)){
        message(" X ERROR: The provided <segments> variable '", paste(segment_vars[[1]], collapse = ", "), "' is not part of\n",
                "          the data frame. Generating graphic will be aborted.")
        return(invisible(NULL))
    }

    # Make sure there is no column variable that is also a row variable.
    segment_vars <- resolve_intersection(segment_vars, axes_vars, check_only = TRUE)

    if (is.list(segment_vars)){
        message(" X ERROR: The provided <segments> variable '", paste(segment_vars[[1]], collapse = ", "), "' is also part of\n",
                "          the <axes variables> variables. Generating graphic will be aborted.")
        return(invisible(NULL))
    }

    if (length(segments) <= 1){
        if (length(segments) == 0 || segments == ""){
            message(" X ERROR: No valid <segments> provided. Generating graphic will be aborted.")
            return(invisible(NULL))
        }
    }

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # By variables
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    # Convert to character vectors
    by <- get_origin_as_char(by, substitute(by))

    # Make sure that the variables provided are part of the data frame.
    by <- data_frame |> part_of_df(by)

    # Make sure there is no row/column variable that is also a by variable.
    variables  <- c(axes_variables, segment_vars)
    by <- resolve_intersection(by, variables, check_only = TRUE)

    if (is.list(by)){
        message(" X ERROR: The provided <by> variable '", paste(by[[1]], collapse = ", "), "' is also part of\n",
                "          the <axes variables> or <segment> variables which is not allowed. Generating graphic will be aborted.")
        return(invisible(NULL))
    }

    if (length(by) == 1){
        if (by == ""){
            message(" X ERROR: No valid <by> variables provided. Generating graphic will be aborted.")
            return(invisible(NULL))
        }
    }

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Weight
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    weight     <- get_origin_as_char(weight, substitute(weight))
    data_frame <- data_frame |> check_weight(weight)
    weight_var <- ".temp_weight"

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Values
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    # Convert to character vectors
    values <- get_origin_as_char(values, substitute(values))

    # If no value variables are provided abort
    if (length(values) <= 1){
        if (length(values) == 0 || values == ""){
            message(" X ERROR: No <values> provided. Generating graphic will be aborted.")
            return(invisible(NULL))
        }
    }

    # Make sure there is no row/column variable that is also a value variable.
    values <- resolve_intersection(values, variables, check_only = TRUE)

    if (is.list(values)){
        message(" x ERROR: The provided <axes>/<segments> variable '", paste(values[[1]], collapse = ", "), "' is also part of\n",
                "          the <values> variables. Generating graphic will be aborted.")
        return(invisible(NULL))
    }

    # Make sure that the variables provided are part of the data frame.
    values <- data_frame |> part_of_df(values)

    if (length(values) == 0){
        message(" X ERROR: No valid <values> variables provided. Generating graphic will be aborted.")
        return(invisible(NULL))
    }

    values <- remove_doubled_values(values)

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Pre summarised data
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    pre_summed <- data_frame |> is_pre_summed(c(by, variables))

    # In case of using a pre summarised data frame, underscores are only allowed, if they carry
    # the statistics extension afterwards.
    if (pre_summed){
        # Only keep provided variables, otherwise it can happen later on that e.g. too many
        # variables are pivoted
        data_frame <- data_frame |> keep(by, variables, values, ".temp_weight")

        # If the TYPE variable isn't present in the data frame it will be generated here from
        # the provided variables.
        if (!"TYPE" %in% names(data_frame)){
            # For each observation check the non NA variables and combine their names in the TYPE
            # variable.
            data_frame[["TYPE"]] <- apply(data_frame[c(by, variables)], 1,
                function(variable){
                    var_name <- names(variable)[!is.na(variable)]

                    if (length(var_name) == 0){
                        NA_character_
                    }
                    else{
                        paste(var_name, collapse = "+")
                    }
                })

            data_frame |> data.table::setcolorder(c(by, variables, "TYPE"))
        }

        # Check if value variables have statistics extension
        extensions <- c("_sum", "_pct_group", "_pct_total", "_pct_value", "_pct", "_freq_g0",
                        "_freq", "_mean", "_median", "_mode", "_min", "_max", "_first",
                        "_last", "_sum_wgt", "_p[0-9]+$", "_sd", "_variance", "_missing")
        pattern    <- paste0("(", paste(extensions, collapse = "|"), ")$")

        # If one of the value variables hasn't got any of the above extension, add extensions automatically as provided
        if (!all(grepl(pattern, values))){
            message(" ! WARNING: All <values> variables need to have the <statistic> extension in their variable name.\n",
                    "            You can use the function 'add_extension' to achieve this. Provided <statistic> will be used.\n",
                    "            This can lead to a wrong table structure, better add extensions by yourself.")

            data_frame <- data_frame |> add_extension(length(c(by, variables, "TYPE")) + 1,
                                                      rep(statistics, length(values))[1:length(values)])
        }

        # Set up options to make sure nothing errors below. Statistics is set to "mean"
        # because then summarise_plus takes a route where factor variables are kept in order.
        # With "sum" the order would be messed up.
        statistics <- "mean"
        pct_value  <- ""
        weight     <- NULL
        formats    <- list()

        rm(extensions, pattern)
    }

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Statistics
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    if (!pre_summed){
        list_of_statistics <- get_complete_statistics_list(statistics)

        # Check for invalid statistics
        valid_stats   <- statistics[statistics %in% c(names(list_of_statistics), "sum_wgt", "pct_value",
                                                      "pct_group", "pct_total", paste0("p", 1:100))]
        invalid_stats <- statistics[!statistics %in% c(names(list_of_statistics), "sum_wgt", "pct_value",
                                                       "pct_group", "pct_total", paste0("p", 1:100))]

        if (length(invalid_stats) > 0){
            message(" ! WARNING: <Statistic> '", invalid_stats, "' is invalid and will be omitted.")

            if (length(valid_stats) == 0){
                message(" ! WARNING: No valid <statistic> selected. 'sum' will be used.")

                statistics <- "sum"
            }
        }
        rm(list_of_statistics, invalid_stats)
    }

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Percentages
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    # If pct_value is selected, make sure sum is also part of statistics
    flag_remove_sum <- FALSE

    if ("pct_value" %in% tolower(statistics) && length(statistics) == 1){
        statistics      <- c(statistics, "sum")
        flag_remove_sum <- TRUE
    }

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Diagram
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    # Evaluate the diagram parameter to see if it is a function
    diagram_name <- get_origin_as_char(diagram, substitute(diagram))

    if (!is.function(diagram)){
        message(" ! WARNING: '", diagram_name, "' is not a function. Vertical bars\n",
                "            will be used instead.")

        diagram <- match.fun("vbars")
    }

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Resolve macros
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    titles      <- apply_macro(titles)
    footnotes   <- apply_macro(footnotes)
    var_labels  <- apply_macro(var_labels)
    stat_labels <- apply_macro(stat_labels)

    ###########################################################################
    # Any Generating graphic starts
    ###########################################################################

    #-------------------------------------------------------------------------#
    monitor_df <- monitor_df |> monitor_next("Summary", "Summary")
    #-------------------------------------------------------------------------#
    message("\n > Computing stats")

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Some preparations beforehand
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    # Put together vector of grouping variables
    group_vars <- c(by, variables)

    # Put combinations in a single vector
    combinations <- as.vector(outer(axes_variables, segments, paste, sep = " + "))

    # In case by variables are specified, add by to group variables and build
    # additional combinations
    if (length(by) > 0){
        combinations <- as.vector(outer(by, combinations, paste, sep = "+"))
    }

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Summarise data according to provided variables
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    # Compute statistics
    if (!pre_summed){
        graphic_tab <- suppressMessages(data_frame |>
              summarise_plus(class      = group_vars,
                             values     = values,
                             statistics = statistics,
                             formats    = formats,
                             weight     = weight_var,
                             nesting    = "all",
                             types      = combinations,
                             notes      = FALSE,
                             na.rm      = na.rm,
                             print_miss = print_miss)) |>
            collapse::fsubset(TYPE != "total")
    }
    else{
        # With pre summarised data just take the input data frame
        graphic_tab <- data_frame
    }

    if (is.null(graphic_tab)){
        message(" X ERROR: Table could not be computed. Execution will be aborted.")
        return(invisible(NULL))
    }

    # Convert grouping variables to factor to retain value order after sorting later on
    graphic_tab <- graphic_tab |> convert_factor(group_vars)

    # In case of pre summarised data frame remove the temporary weight variable
    if (pre_summed){
        graphic_tab <- graphic_tab |> collapse::fselect(-.temp_weight)
    }

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Handle by variables
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    # In case of by variables fuse them into one
    if (length(by) > 0){
        graphic_tab <- graphic_tab |> fuse_variables("by_vars", by)

        # Normally extract the first variable from the TYPE combination into a
        # separate BY variable.
        if (!pre_summed){
            graphic_tab[["BY"]]   <- sub("\\+.*", "", graphic_tab[["TYPE"]])
            graphic_tab[["TYPE"]] <- sub("^[^+]*\\+\\s*", "", graphic_tab[["TYPE"]])
        }
        # In case of pre summarised data frame it is not clear, at which position
        # the by variable is in the TYPE.
        else{
            # Get TYPE variable as list of variable combinations
            type_split <- strsplit(graphic_tab[["TYPE"]], "\\+")

            # If by variable was found in a variable combination, put it into
            # a separate variable.
            graphic_tab[["BY"]] <- vapply(type_split, function(obs){
                by_found <- obs[obs %in% by]

                if (length(by_found) > 0){
                    by_found[1]
                }
                else{
                    ""
                }
            }, character(1L))

            # The TYPE variable itself is put back together as all variables which
            # are no by-Variables.
            graphic_tab[["TYPE"]] <- vapply(type_split, function(obs){
                paste(obs[!obs %in% by], collapse = "+")
            }, character(1L))
        }

        # Convert to factor to keep them in order when sorting later
        graphic_tab <- graphic_tab |> convert_factor(c("BY", "by_vars"))
    }

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Handle percentages based on value variables
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    # In case percentages based on value variables should be computed
    if ("pct_value" %in% tolower(statistics) && length(pct_value) > 0){
        for (i in seq_along(pct_value)){
            value <- pct_value[[i]]
            name  <- names(pct_value)[i]

            # Separate provided variables first
            eval_vars <- trimws(strsplit(value, split = "/")[[1]])

            # Compute percentages
            if (paste0(eval_vars[1], "_sum") %in% names(graphic_tab) &&
                paste0(eval_vars[2], "_sum") %in% names(graphic_tab)){
                graphic_tab[[paste0(name, "_pct_value")]] <-
                    graphic_tab[[paste0(eval_vars[1], "_sum")]] * 100 /
                    graphic_tab[[paste0(eval_vars[2], "_sum")]]
            }
            # Without sum percentages can't be computed
            else{
                flag_remove_sum <- FALSE

                # Additional warnings for missing variables
                if (!eval_vars[1] %in% names(data_frame)){
                    message(" ! WARNING: Variable '", eval_vars[1], "' not found in the data frame.")
                }
                if (!eval_vars[2] %in% names(data_frame)){
                    message(" ! WARNING: Variable '", eval_vars[2], "' not found in the data frame.")
                }
            }
        }

        if (flag_remove_sum){
            graphic_tab <- graphic_tab |> dropp(":_sum")
        }

        rm(eval_vars, i, value, flag_remove_sum)
    }

    rm(data_frame)

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Round values
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    # Reorder variables according to statistics. This is necessary because pct_value
    # can only be computed after summarise_plus and therefor isn't ordered.
    graphic_tab <- graphic_tab |> setcolorder_by_pattern(statistics)

    # Get value variable names
    if (length(by) == 0){
        var_vector <- c(variables, "TYPE", "TYPE_NR", "DEPTH")
        value_vars <- graphic_tab |> inverse(var_vector)
    }
    else{
        var_vector <- c(variables, "TYPE", "TYPE_NR", "DEPTH", "by_vars", "BY")
        value_vars <- graphic_tab |> inverse(var_vector)
    }

    # Round values according to number formats
    for (var_name in names(graphic_tab)){
        if (!var_name %in% value_vars){
            next
        }

        # Get stat from variable name
        stat <- strsplit(var_name, split = "_")[[1]]
        stat <- stat[length(stat)]

        # Round values to the decimals places specified in the style
        if (tolower(stat) %in% c("sum", "freq", "freq", "mean", "median", "mode",
                                 "min", "max")){
            graphic_tab[[var_name]] <- round(graphic_tab[[var_name]],
                                         number_formats[[paste0(stat, "_decimals")]])
        }
        else if(stat == "g0"){
            graphic_tab[[var_name]] <- round(graphic_tab[[var_name]],
                                         number_formats[["freq_decimals"]])
        }
        else if(stat == "wgt"){
            graphic_tab[[var_name]] <- round(graphic_tab[[var_name]],
                                         number_formats[["sum_decimals"]])
        }
        else if(grepl("^[0-9]$", substr(stat, 2, 2))){
            graphic_tab[[var_name]] <- round(graphic_tab[[var_name]],
                                         number_formats[["p_decimals"]])
        }
        else{
            graphic_tab[[var_name]] <- round(graphic_tab[[var_name]],
                                         number_formats[["pct_decimals"]])
        }
    }

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Prepare table format for output
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    #-------------------------------------------------------------------------#
    monitor_df <- monitor_df |> monitor_next("Excel prepare", "Format")
    #-------------------------------------------------------------------------#
    message(" > Formatting tables")

    monitor_df <- monitor_df |> monitor_end()

    # In case no by variables are provided
    if (length(by) == 0){
        graphic_list <- generate_graphic(graphic_tab, axes_vars, segment_vars, statistics,
                                         by, titles, footnotes, var_labels, stat_labels,
                                         diagram, color_theme, color_usage, visuals, axes, dimensions,
                                         add_texts, output, monitor_df = monitor_df)

        plot_element <- graphic_list[[1]]
        monitor_df   <- graphic_list[[2]]
    }
    # In case there are  by variables are provided
    else{
        graphic_list <- generate_graphic_by(graphic_tab, axes_vars, segment_vars, statistics,
                                            by, titles, footnotes, var_labels, stat_labels,
                                            diagram, color_theme, color_usage, visuals, axes, dimensions,
                                            add_texts, output, na.rm, print_miss, monitor_df)

        plot_element <- graphic_list[[1]]
        monitor_df   <- graphic_list[[2]]
    }

    end_time <- round(difftime(Sys.time(), start_time, units = "secs"), 3)
    message("\n- - - 'design_graphic' execution time: ", end_time, " seconds\n")

    #-------------------------------------------------------------------------#
    monitor_df <- monitor_df |> monitor_end()
    monitor_df |> monitor_plot(draw_plot = monitor)
    #-------------------------------------------------------------------------#

    invisible(list("table"   = graphic_tab,
                   "graphic" = plot_element))
}


###############################################################################
# Format any table for excel output
###############################################################################
#' Format Any Table Output (Excel Based)
#'
#' @description
#' Format any table with the provided row and column variables. Statistics
#' can be anything available.
#'
#' @param graphic_tab The data frame which contains the information for this graphic.
#' @param axes_vars A vector containing the axes variables.
#' @param segment_vars A vector containing the segment variables.
#' @param statistics The user requested statistics.
#' @param by Separate the graphics output by the expressions of the provided variables.
#' @param titles Specify one or more table titles.
#' @param footnotes Specify one or more table footnotes.
#' @param var_labels A list in which is specified which label should be printed for
#' which variable instead of the variable name.
#' @param stat_labels A list in which is specified which label should be printed for
#' which statistic instead of the statistic name.
#' @param diagram Function that provides the generation of the main diagram area.
#' @param color_theme The color theme to use. Can either be the name of a built-in or
#' custom theme or a vector of hex codes. Existing color themes can be viewed with
#' [display_themes()].
#' @param color_usage A list of numerical vectors that specify which specific colors
#' from the color scheme are used for which number of segments.
#' @param visuals Visual parameters set with [graphic_visuals()].
#' @param axes Axes parameters set with [graphic_axes()].
#' @param dimensions Dimension parameters set with [graphic_dimensions()].
#' @param add_texts Use the [add_textbox()] function to freely place one or multiple textboxes.
#' @param output Output parameters set with [graphic_output()].
#' @param by_info Text which contains the information which variable with which
#' expression is computed at the moment. Used for computation with by variables.
#' @param index Index of the current variable expression. Used for computation with
#' by variables.
#' @param monitor FALSE by default. If TRUE, outputs two charts to visualize the functions time consumption.
#'
#' @return
#' Returns a list containing a formatted Excel workbook as well as the monitoring
#' data frame.
#'
#' @noRd
generate_graphic <- function(graphic_tab,
                             axes_vars,
                             segment_vars,
                             statistics,
                             by,
                             titles,
                             footnotes,
                             var_labels,
                             stat_labels,
                             diagram,
                             color_theme,
                             color_usage,
                             visuals,
                             axes,
                             dimensions,
                             add_texts,
                             output,
                             by_info = NULL,
                             index   = NULL,
                             monitor_df){
    #-------------------------------------------------------------------------#
    monitor_df <- monitor_df |> monitor_start("General design", "Format")
    #-------------------------------------------------------------------------#
    values <- utils::tail(names(graphic_tab), 1)
    # TODO: HANDLE MULTIPLE VALUE VARIABLES

    # Register font
    register_windows_font(visuals[["font"]])

    # Setup main canvas
    viewport <- setup_main_canvas(width  = dimensions[["graphic_width"]],
                                  height = dimensions[["graphic_height"]],
                                  background_color = visuals[["graphic_background_color"]],
                                  border_color     = visuals[["graphic_border_color"]])

    # Get titles and footnotes as graphical objects
    title_grob    <- add_title(titles, dimensions, visuals)
    footnote_grob <- add_footnote(footnotes, dimensions, visuals)
    origin_grob   <- add_graphic_origin(dimensions, visuals)

    # TODO: ADD ADDITIONAL SUB HEADLINE
    # Get graphic element heights
    title_height    <- abs(grid::convertHeight(grid::grobHeight(title_grob),    "cm", valueOnly = TRUE))
    footnote_height <- abs(grid::convertHeight(grid::grobHeight(footnote_grob), "native", valueOnly = TRUE))
    origin_height   <- abs(grid::convertHeight(grid::grobHeight(origin_grob),   "native", valueOnly = TRUE))

    # Draw main diagram
    main_grob <- diagram(graphic_tab,
                         c(axes_vars),
                         c(segment_vars),
                         c(values),
                         c(statistics),
                         var_labels,
                         stat_labels,
                         c(color_theme),
                         color_usage,
                         visuals,
                         axes,
                         dimensions,
                         title_height,
                         footnote_height,
                         origin_height)

    # Go back to the main canvas to be able to draw additional textboxes freely
    back_to_the_root()

    # TODO: INSERT CUSTOM TEXTBOXES
    viewport_path <- c(grid::current.vpPath()[["name"]],
                       main_grob[["meta"]][["outer_viewport"]][["name"]],
                       main_grob[["meta"]][["inner_viewport"]][["name"]])

    viewport_tree <- grid::current.viewport() |>
        grid::vpStack(
            main_grob[["meta"]][["outer_viewport"]],
            main_grob[["meta"]][["inner_viewport"]])

    whole_graphic <- grid::gTree(children = grid::gList(title_grob,
                                                        grid::editGrob(main_grob[["graphic"]], vp = grid::vpPath(viewport_path)),
                                                        footnote_grob, origin_grob),
                                 childrenvp = viewport_tree)

    # Draw and save the graphic
    output_graphic(whole_graphic, dimensions, output)

    grid::popViewport()

    #-------------------------------------------------------------------------#
    monitor_df <- monitor_df |> monitor_start("Special design", "Format")
    #-------------------------------------------------------------------------#

    monitor_df <- monitor_df |> monitor_end()

    # Return workbook
    list(whole_graphic, monitor_df)
}


###############################################################################
# Format grouped by tables for excel output
###############################################################################
#' Format Any Table Output with by Variables (Excel Based)
#'
#' @description
#' Format any table with the provided row and column variables. Data frame is split
#' by by-variables, each table gets printed on a different sheet.
#'
#' @param graphic_tab The data frame which contains the information for this graphic.
#' @param axes_vars A vector containing the axes variables.
#' @param segment_vars A vector containing the segment variables.
#' @param statistics The user requested statistics.
#' @param by Separate the graphics output by the expressions of the provided variables.
#' @param titles Specify one or more table titles.
#' @param footnotes Specify one or more table footnotes.
#' @param var_labels A list in which is specified which label should be printed for
#' which variable instead of the variable name.
#' @param stat_labels A list in which is specified which label should be printed for
#' which statistic instead of the statistic name.
#' @param diagram Function that provides the generation of the main diagram area.
#' @param color_theme The color theme to use. Can either be the name of a built-in or
#' custom theme or a vector of hex codes. Existing color themes can be viewed with
#' [display_themes()].
#' @param color_usage A list of numerical vectors that specify which specific colors
#' from the color scheme are used for which number of segments.
#' @param visuals Visual parameters set with [graphic_visuals()].
#' @param axes Axes parameters set with [graphic_axes()].
#' @param dimensions Dimension parameters set with [graphic_dimensions()].
#' @param add_texts Use the [add_textbox()] function to freely place one or multiple textboxes.
#' @param output Output parameters set with [graphic_output()].
#' @param na.rm If TRUE removes all NA values from the tabulation.
#' @param print_miss FALSE by default. If TRUE outputs all possible categories of the
#' grouping variables based on the provided formats, even if there are no observations
#' for a combination.
#' @param monitor FALSE by default. If TRUE, outputs two charts to visualize the functions time consumption.
#'
#' @return
#' Returns a list containing a formatted Excel workbook as well as the monitoring
#' data frame.
#'
#' @noRd
generate_graphic_by <- function(graphic_tab,
                                axes_vars,
                                segment_vars,
                                statistics,
                                by,
                                titles,
                                footnotes,
                                var_labels,
                                stat_labels,
                                diagram,
                                color_theme,
                                color_usage,
                                visuals,
                                axes,
                                dimensions,
                                add_texts,
                                output,
                                na.rm,
                                print_miss,
                                monitor_df){

    # NOTE: JUST RENAMED PLACEHOLDER FROM ANY_TABLE

    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # Loop through all by variables
    #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    index <- 1

    for (by_var in by){
        #---------------------------------------------------------------------#
        monitor_df <- monitor_df |> monitor_start(paste0("Excel prepare (", by_var, ")"), "Format by")
        #---------------------------------------------------------------------#

        # Select by variables one by one
        graphic_by <- graphic_tab |>
            collapse::fsubset(graphic_tab[["BY"]] == by_var)

        # Extract unique values
        if (anyNA(graphic_by[["by_vars"]])){
            values <- c(collapse::funique(collapse::na_omit(graphic_by[["by_vars"]])), NA)
        }
        else{
            values <- collapse::funique(graphic_by[["by_vars"]])
        }

        monitor_df <- monitor_df |> monitor_end()

        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        # Loop through all unique values to generate tables per expression
        #++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        for (value in values){
            # In case NAs are removed
            if (is.na(value) && na.rm){
                next
            }

            #-----------------------------------------------------------------#
            monitor_df <- monitor_df |> monitor_start(paste0("Excel (", by_var, "_", value, ")"), "Format by")
            #-----------------------------------------------------------------#
            message("   + ", paste0(by_var, " = ", value))

            # Put additional by info together with the information which by variable
            # and which value is currently filtered.
            by_info <- paste0(by_var, " = ", value)

            # Filter table by current by variable and value
            if (!is.na(value)){
                graphic_temp <- graphic_by |>
                    collapse::fsubset(graphic_by[["by_vars"]] == value)
            }
            else{
                graphic_temp <- graphic_by |>
                    collapse::fsubset(is.na(graphic_by[["by_vars"]]))
            }

            graphic_temp <- graphic_temp |> dropp("BY", "by_vars")

            # Add by info below the titles
            if (length(titles) > 0){
                titles_temp <- c(titles, "", by_info)
            }
            # Or on top if there are no titles
            else{
                titles_temp <- by_info
            }

            # Generate tables as normal but base is filtered data frame
            current_graphic <- generate_graphic(graphic_tab,
                                                axes_vars,
                                                segment_vars,
                                                statistics,
                                                by,
                                                titles,
                                                footnotes,
                                                var_labels,
                                                stat_labels,
                                                color_theme,
                                                visuals,
                                                axes,
                                                dimensions,
                                                add_texts,
                                                output,
                                                by_info,
                                                index,
                                                NULL)

            index <- index + 1

            graphic_list <- c(graphic_list, current_graphic)

            monitor_df <- monitor_df |> monitor_end()
        }

        monitor_df <- monitor_df |> monitor_end()
    }

    # Return workbook
    list(graphic_list, monitor_df)
}
